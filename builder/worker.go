package builder

import (
	"bytes"
	"fmt"
	"path/filepath"
	"sync"
	"time"

	"github.com/mebyus/gizmo/gencpp"
	"github.com/mebyus/gizmo/ir/origin"
	"github.com/mebyus/gizmo/parser"
)

type BuildTask struct {
	dep *DepEntry

	// order number of this task, used to produce deterministic
	// build results when gathering outputs from multiple workers
	order int
}

type BuildTaskResult struct {
	task *BuildTask

	// output generated by build
	genout []byte

	err error
}

const poolSize = 8

type Pool struct {
	output BuildOutput

	wg sync.WaitGroup

	tasks []*BuildTask

	cache *Cache
}

func NewPool(cache *Cache, tasknum int) *Pool {
	return &Pool{
		tasks: make([]*BuildTask, 0, tasknum),
		cache: cache,
	}
}

func (p *Pool) AddTask(task *BuildTask) {
	order := len(p.tasks)
	task.order = order
	p.tasks = append(p.tasks, task)
}

func (p *Pool) Start() {
	tasks := make(chan *BuildTask, 16)
	results := make(chan *BuildTaskResult, 16)
	stop := make(chan struct{})

	wctl := WorkerControls{
		wg: &p.wg,

		tap:  tasks,
		sink: results,
		stop: stop,
	}

	for i := 0; i < poolSize; i++ {
		p.wg.Add(1)
		go SpawnWorker(p.cache, wctl)
	}

	sctl := StaplerControls{
		wg: &p.wg,

		tap:   results,
		stop:  stop,
		parts: len(p.tasks),
	}

	p.wg.Add(1)
	go SpawnStapler(&p.output, sctl)

	dctl := DispatcherControls{
		wg: &p.wg,

		sink: tasks,
		stop: stop,
	}

	p.wg.Add(1)
	go SpawnDispatcher(p.tasks, dctl)
}

func (p *Pool) WaitDone() {
	p.wg.Wait()
}

func (p *Pool) WaitOutput() BuildOutput {
	p.WaitDone()
	return p.output
}

type DispatcherControls struct {
	wg *sync.WaitGroup

	// outgoing build tasks
	sink chan<- *BuildTask

	// signals dispatcher that it should stop early
	stop <-chan struct{}
}

// SpawnDispatcher meant to be run in a separate goroutine. Fans out supplied tasks
// through sink channel to workers
func SpawnDispatcher(tasks []*BuildTask, ctl DispatcherControls) {
	defer ctl.wg.Done()

	for _, task := range tasks {
		select {
		case ctl.sink <- task:
		case <-ctl.stop:
			return
		}
	}
}

type BuildOutput struct {
	err error

	code []byte
}

type StaplerControls struct {
	wg *sync.WaitGroup

	// incoming build results from workers
	tap <-chan *BuildTaskResult

	// send signal to other goroutines in pool to stop early
	stop chan<- struct{}

	// how many parts stapler expects to receive from tap
	parts int
}

func SpawnStapler(output *BuildOutput, ctl StaplerControls) {
	defer ctl.wg.Done()

	// collection of build results from received from workers
	// index in this slice directly corresponds to BuildTask.order
	results := make([]*BuildTaskResult, ctl.parts)

	// stapler tip index inside results slice
	tip := 0

	var buf bytes.Buffer

	for i := 0; i < ctl.parts; i++ {
		result := <-ctl.tap
		if result.err != nil {
			// signal other goroutines in pool to stop early
			close(ctl.stop)
			output.err = result.err
			return
		}

		results[result.task.order] = result

		// staple available parts together
		for tip < ctl.parts && results[tip] != nil {
			buf.Write(results[tip].genout)
			tip += 1
		}
	}

	if tip != ctl.parts {
		panic(fmt.Sprintf("%d parts were stapled, expected exactly %d", tip, ctl.parts))
	}

	close(ctl.stop)
	output.code = buf.Bytes()
}

// Worker accepts unit build tasks and processes them
type Worker struct {
}

type WorkerControls struct {
	wg *sync.WaitGroup

	// incoming tasks which worker will process
	tap <-chan *BuildTask

	// outgoing build results
	sink chan<- *BuildTaskResult

	// signals worker that it should stop early
	stop <-chan struct{}
}

// SpawnWorker meant to be run in a separate goroutine. Loops through incoming
// tasks, processes them and sends results further
func SpawnWorker(cache *Cache, ctl WorkerControls) {
	defer ctl.wg.Done()

	for {
		select {
		case task, ok := <-ctl.tap:
			if !ok {
				return
			}

			result := processTask(cache, task)

			select {
			case ctl.sink <- result:
			case <-ctl.stop:
				return
			}
		case <-ctl.stop:
			return
		}
	}
}

func processTask(cache *Cache, task *BuildTask) *BuildTaskResult {
	result, err := ProcessTask(cache, task)
	if err != nil {
		return &BuildTaskResult{
			err:  err,
			task: task,
		}
	}
	if result == nil {
		return &BuildTaskResult{task: task}
	}
	return result
}

func ProcessTask(cache *Cache, task *BuildTask) (*BuildTaskResult, error) {
	if len(task.dep.BuildInfo.Files) == 0 {
		return nil, nil
	}

	names := task.dep.BuildInfo.Files
	gizmoFiles := make([]string, 0, len(names))
	var unitModTime time.Time

	for _, name := range names {
		name = filepath.Clean(name)
		if name == "" || name == "." {
			return nil, fmt.Errorf("empty file name")
		}

		dir := filepath.Dir(name)
		if !(dir == "" || dir == ".") {
			return nil, fmt.Errorf("file \"%s\" points to a separate directory", name)
		}

		ext := filepath.Ext(name)
		switch ext {
		case "":
			return nil, fmt.Errorf("file \"%s\" has empty extension", name)
		case ".gzm":
			src, err := cache.InfoSourceFile(task.dep.Path, name)
			if err != nil {
				return nil, err
			}
			if src.ModTime.After(unitModTime) {
				unitModTime = src.ModTime
			}
			gizmoFiles = append(gizmoFiles, name)
		case ".cpp":
			panic("not implemented")
		case ".asm":
			panic("not implemented")
		default:
			return nil, fmt.Errorf("file \"%s\" has extension unknown to builder", name)
		}
	}

	genout, ok := cache.LoadUnitGenout(task.dep.Path, unitModTime)
	if ok {
		return &BuildTaskResult{
			task:   task,
			genout: genout,
		}, nil
	}

	var buf bytes.Buffer

	for _, name := range gizmoFiles {
		err := gizmoGenout(&buf, cache, task.dep.Path, name)
		if err != nil {
			return nil, err
		}
	}

	result := &BuildTaskResult{
		task:   task,
		genout: buf.Bytes(),
	}
	cache.SaveUnitGenout(task.dep.Path, result.genout)
	return result, nil
}

func gizmoGenout(buf *bytes.Buffer, cache *Cache, p origin.Path, name string) error {
	src, err := cache.LoadSourceFile(p, name)
	if err != nil {
		return err
	}
	genout, ok := cache.LoadFileGenout(p, src)
	if ok {
		// implementation always writes all bytes without error
		buf.Write(genout)
		return nil
	}

	atom, err := parser.ParseSource(src)
	if err != nil {
		return err
	}

	start := buf.Len()
	err = gencpp.Gen(buf, atom)
	if err != nil {
		return err
	}
	genout = buf.Bytes()[start:]

	cache.SaveFileGenout(p, src, genout)
	return nil
}
