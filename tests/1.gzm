namespace coven {}

namespace coven::os {

declare fn do_something()

fn do_something() {
    return;
}

fn add(a: u32, b: u32) => u32 {
    const c: u32 = a + b;
    return c;
}

const max_u32: u32 = 0xffffffff;

fn sub(a: i32, b: i32) => i32 {
    var c: i32 = dirty;
    c = a - b;
    return c;
}

// Calculate n-th fibonacci number
fn fib(n: u64) => u64 {
    if n == 0 {
        return 0;
    } else if n == 1 {
        return 1;
    } else {
        return fib(n-1) + fib(n-2);
    }
}

fn change_by_pointer(x: *i32) {
    if x == nil {
        return;
    }

    x.@ = -0xf4;
}

fn call_another_function() {
    fib(5);
}

fn change_array_pointer(a: [*]u8) {
    a.[0] = 'h';
    a.[1] = 'e';
    a.[2] = 'l';
    a.[3] = 'l';
    a.[4] = 'o';
}

type SourceFile struct {
    data: []u8,
}

method (SourceFile) size() => uarch {
    return data.len;
}

type Pos struct {
    file: *SourceFile,

    line: u32,
    col:  u32,
}

const empty_string_test: str = "";
var hello: str = "Hello, world!";

var two: u32 = (1 + 1) - 0 * 2 * (0 + 1 - 0x0 * 7 - 8 + 0o11);

fn print_hello() {
    os::stdout.print(hello);
    os::stdout.flush();
}

/* 
    Test multiline comment

    This should be skipped by lexer
*/

fn stdout_write(c: []u8) {
    os::stdout.write(c);
}

fn return_the_same_chunk(c: []Pos) => []Pos {
    return c;
}

fn for_loop_no_condition() {
    var i: uarch = 0;
    for {
        i += 1;
        if i > 27 {
            return;
        }
    }
}

fn for_loop_with_condition() {
    var i: uarch = 0;
    for i <= 45 {
        i += 1;
        if i > 27 {
            return;
        }
    }
}

fn if_with_always_true() => bool {
    if true {
        os::stdout.print("true branch");
    } else {
        // unreachable
        os::stdout.print("false branch");
    }

    return false;
}

/*
type Error enum u8 {
    Ok,
    EOF,

    Unknown = 0x10,

}
*/

}
