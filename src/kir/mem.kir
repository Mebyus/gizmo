type MemBlockID struct {
    id: u64,
}

type MemBlock struct {
    mem: []u8,
    id:  MemBlockID,
}

type MemError uint

// Allocator does not have enough space to allocate new block
// of specified size.
let MEM_ERROR_NO_SPACE: MemError = 1

type MemArenaAllocator struct {
    ptr: [*]u8,
    pos: uint,
    cap: uint,
}

fun mem_arena_allocator_init(arena: *MemArenaAllocator, buf: []u8) {
    arena.@.ptr = buf.ptr;
    arena.@.pos = 0;
    arena.@.cap = buf.len;
}

fun mem_arena_alloc(arena: *MemArenaAllocator, block: *MemBlock, size: uint) => MemError {
	must(size != 0);

    let aligned_size: uint = align_uint(size, 0x10);
	let left_space: uint = arena.@.cap - arena.@.pos;
	if (left_space < aligned_size) {
		return MEM_ERROR_NO_SPACE;
	}

	block.mem.ptr = arena.@.ptr + arena.@.pos;
	block.mem.len = aligned_size;
    block.id.id = 0;
	
	arena.@.pos += aligned_size;
	return nil;
}

type MemAllocatorKind uint

let MEM_ALLOCATOR_ARENA: MemAllocatorKind = 1;
let MEM_ALLOCATOR_GP:    MemAllocatorKind = 2;

type MemAllocator struct {
    ptr: *any,
    kind: MemAllocatorKind,
}

fun panic_mem_allocator_unknown(kind: MemAllocatorKind) => never {
    panic();
}

fun mem_alloc(al: MemAllocator, block: *MemBlock, size: uint) => MemError {
    if al.kind
    => nil { panic(); }
    => MEM_ALLOCATOR_ARENA {
        return mem_arena_alloc(cast(*MemArenaAllocator, al.ptr), block, size);
    }
    => MEM_ALLOCATOR_GP { stub; }
    else {
        panic_mem_allocator_unknown(al.kind);
    }
}
