fun fmt_dec_digit(x: u8) => u8 {
	return x + tint(u8, '0');
}

fun fmt_hex_digit(x: u8) => u8 {
	if x <= 9 {
		return fmt_dec_digit(x);
	}
	return x - 10 + tint(u8, 'A');
}

fun unsafe_fmt_hex_byte(buf: []u8, x: u8) => uint {
  	buf.ptr.[0] = fmt_hex_digit(x >> 4);
	buf.ptr.[1] = fmt_hex_digit(x & 0xF);
	return 2;
}

let max_u64_dec_length: uint = 20;

/*
Same as fmt_dec_u64, but has no buffer boundary checks.
*/
fun unsafe_fmt_dec_u64(buf: []u8, x: u64) => uint {
	var digits: [max_u64_dec_length]u8 = dirty;
	var i: uint = 0;
	for {
		let n: u8 = tint(u8, x % 10);
		x /= 10;
		digits.[i] = fmt_dec_digit(n);
		i += 1;
		if x == 0 {
			let len: uint = i;
			unsafe_reverse_copy(buf.ptr, digits, len);
			return len;
		}
	}
}

/*
Puts integer x into a given buffer as text in decimal format.

Returns number of bytes written. Returns 0 if buffer does not
have enough bytes for the operation.
*/
fun fmt_dec_u64(buf: []u8, x: u64) => uint {
	if buf.len == 0 {
		return 0;
	}
	must(buf.ptr != nil);
	
	if buf.len >= max_u64_dec_length {
		return unsafe_fmt_dec_u64(buf, x);
	}
	
	var digits: [max_u64_dec_length]u8 = dirty;
	var i: uint = 0;
	for {
		let n: u8 = tint(u8, x % 10);
		x /= 10;
		digits.[i] = fmt_dec_digit(n);
		i += 1;
		if x == 0 {
			let len: uint = i;
			if len > buf.len {
				// Not enough space in buffer to represent integer.
				return 0;
			}
			unsafe_reverse_copy(buf.ptr, digits, len);
			return len;
		}
	}
}

type FormatBuffer struct {
	// Pointer to buffer memory.
	// Always not nil for initialized struct.
	ptr: [*]u8,

	// Content length. How many bytes is already written to buffer.
	// Length cannot be greater than capacity.
	len: uint,

	// Buffer storage capacity. Max bytes it can hold.
	cap: uint,
}

fun fmt_buffer_init(buf: *FormatBuffer, c: []u8) {
    must(c.ptr != nil);

    buf.@.ptr = c.ptr;
    buf.@.len = 0;
    buf.@.cap = c.len;
}

fun make_fmt_buffer(c: []u8) => FormatBuffer {
	var buf: FormatBuffer = dirty;
    fmt_buffer_init(buf.&, c);
	return buf;
}

fun fmt_buffer_head(buf: *FormatBuffer) => []u8 {
	return make_bx(buf.@.ptr, buf.@.len);
}

fun fmt_buffer_tail(buf: *FormatBuffer) => []u8 {
	return make_bx(buf.@.ptr + buf.@.len, buf.@.cap - buf.@.len);
}

// Returns actual number of bytes written to buffer.
fun fmt_buffer_put_str(buf: *FormatBuffer, s: str) => uint {
	let n: uint = copy(fmt_buffer_tail(buf), s);
	buf.@.len += n;
	return n;
}

fun fmt_buffer_put_byte(buf: *FormatBuffer, b: u8) => uint {
	var tail: []u8 = fmt_buffer_tail(buf);
	if (tail.len == 0) {
		return 0;
	}
	tail.ptr[0] = b;
	buf.@.len += 1;
	return 1;
}

fun fmt_buffer_put_hex_byte(buf: *FormatBuffer, x: u8) => uint {
	var tail: []u8 = fmt_buffer_tail(buf);
	if (tail.len < 2) {
		return 0;
	}
	unsafe_fmt_hex_byte(tail, x);
	buf.@.len += 2;
	return 2;
}

fun fmt_buffer_put_nl(buf: *FormatBuffer) => uint {
	return fmt_buffer_put_byte(buf, '\n');
}

fun fmt_buffer_put_space(buf: *XkFormatBuffer) => uint {
	return fmt_buffer_put_byte(buf, ' ');
}

fun fmt_buffer_put_dec_u64(buf: *FormatBuffer, x: u64) => uint {
	let n: uint = fmt_dec_u64(fmt_buffer_tail(buf), x);
	buf.@.len += n;
	return n;
}

fun fmt_buffer_put_dec_s64(buf: FormatBuffer, x: s64) => uint {
	let n: uint = fmt_dec_s64(fmt_buffer_tail(buf), x);
	buf.@.len += n;
	return n;
}

fun fmt_buffer_put_hex_prefix_zeroes_u16(buf: *FormatBuffer, x: u16) => uint {
	let n: uint = fmt_hex_prefix_zeroes_u16(fmt_buffer_tail(buf), x);
	buf.@.len += n;
	return n;
}

fun fmt_buffer_put_hex_prefix_zeroes_u64(buf: *FormatBuffer, x: u64) => uint {
	let n: uint = fmt_hex_prefix_zeroes_u64(fmt_buffer_tail(buf), x);
	buf.@.len += n;
	return n;
}
