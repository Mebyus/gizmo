fn dec_digit(x: u8) => u8 {
	return x + '0';
}

fn unsafe_put_reverse(d: []u8, s: []u8) {
	var i: uint = 0;
	var j: uint = s.len - 1;
	for i < s.len {
		d.ptr.[j] = s.ptr.[i];
		i += 1;
		j -= 1;
	}
}

let max_u64_dec_length: u64 = 20;

// Formats integer into a given chunk as a decimal number.
// Returns number of bytes occupied by formatted number.
// Returns zero if formatted number does not fit into chunk.
// In the latter case implementation guarantees that given
// chunk remains untouched, even temporarily.
fn dec_u64(buf: []u8, x: u64) => uint {
	// buffer for digits in reverse order
	var b: [max_u64_dec_length]u8 = dirty;

	var i: uint = 0;
	for {  
		let n: u8 = cast[x % 10: u8];
		x /= 10;
		b[i] = dec_digit(n);
		i += 1;
		
		if x == 0 {
			// length of formatted number in bytes
			let len: uint = i; 

			if len > buf.len {
				// chunk does not have enough space to represent given number
				return 0;
			}

			unsafe_put_reverse(buf, b[:len]);
			return i;
		}
	}
}
